\documentclass{IEEEtran}

\begin{document}
\bibliographystyle{IEEEtran}

\title{Package Universes:\\
       A Policy-Neutral Architecture for\\Evolving Collaborative Libraries}
\author{S. Alexander Spoon}
\maketitle


\section{Introduction}

Many long-term collaborations can be described in terms of developing
a shared library of content that is stored in discrete packages.  
%XXX find collaboration theory here!
Examples include systems like the Debian's Advanced Package Tool and
Squeak's SqueakMap for managing software packages, SuperSwikis for
managing Etoys content \cite{steinmetz02:learning}, and Wikis for
managing written articles \cite{ward01:wikiway}.  Frequently the
individual packages evolve over time: software gains new
features and bug fixes, media content is updated, and articles are
edited.  Additionally, this content frequently includes dependencies.
A software package for email reading might depend on having an HTML
formatter, and an active essay in an Etoys-like media system might
require that particular widget classes be loaded before the essay is
viewable.  Finally, while many such collaborations require few firm
rules, it is common for wide-open freedom in the collaboration space
to be limited to some form of membership in an existing external
community such as a single software-development team or a single
classroom.  While such restrictions tend to be simple, the precise
policies vary widely among different collaboration communities.


This paper describes \emph{package universes}, an architecture for
supporting these kinds of collaborations.  A package universe itself
is a sort of bubble universe, limited view on all of the possible
packages that can or might exist.  The limited view provides leverage
for simple implementations of a variety of useful human organizations
and software-engineering processes.

The architecture is interesting for being small while still allowing
convenient implementation of a wide variety number of collaboration
organizations and software-engineering policies.  The architecture is
small and is policy-neutral in important ways, but it nevertheless
includes sufficient support that common policies can be implemented in
a matter of minutes.

This paper describes the architecture itself, discusses rationale and
theory, describes several useful configurations possible within the
architecture, and reports experience based on implementations in
Squeak \cite{ingalls97:future} and Scala \cite{odersky04:scala}.


\section{Architecture}
The overall architecture is that a package universe implements a
\emph{shared library} of \emph{packages} on the network, while
individual users have a \emph{workspace} that includes a \emph{local
library}.  The local library consists of packages selectively
downloaded from the shared library.

A package is the unit of interchange of content.  It might contain any
form of content---software, media components, written essays, etc.  A
package can be loaded and unloaded from the user's local library.
Each package has a name, used to refer to the package from the
workspace and (possibly) from the content of other packages, and it
has a version number, used to distinguish different revisions of the same
content.

The shared library is implemented by a package universe.  A package
universe is defined as an evolving set of packages.  Users can
retrieve the current list of packages, add packages to the set, and
remove packages from the set.

\emph{Primitive} package universes are directly implemented of a list
of packages on a server.  \emph{Compound} package universes can be
formed from underlying universes using the following operators:
\begin{itemize}
\item Union.  Any two universes may be combined to form a larger
      universe.  The ordering of the union is specified, thus allowing
      the contents of one universe to override another.  The effect
      is the same as (multiple) inheritance in an object-oriented language.

\item Positive filtering.  It is possible to make a universe that
      includes just those packages from another universe whose
      name is included in some list of package names.

\item Negative filtering.  Likewise, it is possible to make a universe
      that \emph{excludes} packages whose name is on some list.

\item Name-based union.  A useful combination of these filters, named
      separately due to its frequent utility, is to take the union of
      two universes but filter out all packages from one universe
      which have any same-named package in the other universe.  This
      approach provides inheritance where overrides are based on names
      of packages instead of name-version tuples.
\end{itemize}


It seems likely that the compound universe used by a particular
community might be a complicated application of several of the above
operators.  Additionally, it seems likely that communities will
refine the definition of its package universe(s) over time.  For both
reasons, it seems helpful to store the definition of the universe on
the network and have the client reference the definition via a URL.
The community can then modify the definition of the universe in a
single central location.  Each individual user's software can
periodically and automatically download a fresh copy of the universe
definition.

This form of automatic updating leads to the intriguing possibility of
storing the universe definition itself in some universe.  For example,
there might be meta-universes that hold only universe descriptions.
More practically, the universe description might be stored inside
itself, leading to meta-circularity between a universe and its
description.



\section{Rationale: Why Sets of Packages?}

Why focus on package universes as the core of the architecture?
Packages are only \emph{convenient} when they have been
\emph{configured} consistently with other packages a user wants to
use.  Individual packages are only \emph{reliable}, in practice, when
they are \emph{tested} with respect to other packages the user is
interested in.  Therefore, package in general cannot be convenient and
cannot be reliable except in relation to a set of other packages.
As a result, the set of all possible packages naturally divides itself into
smaller sets of mutually compatible packages.

Besides being part of the fundamental nature of packages, however,
these sets of mutually compatible packages provide useful leverage.
Sets of packages provide a useful place to insert policy, they
simplify dependency management, and they allow for relatively short
names of packages.

These sets are called \emph{package universes} in this system because
they constitute the entire set of packages visible from an individual
user workspace.  Intuitively, it is as if each user operates within a
bubble universe, unable to see anything except what has been placed in
that universe.  Such universes can be quite large, easily including
tens of thousands of packages, but each one is always limited to
packages that have been explicitly added and thus which fit each
universe's policy for inclusion.


\section{Names, Versions, and Dependencies}

Package names are considered unique within a particular universe.
Thus, if two packages have the same name but a different version
number, they are considered as holding different revisions of the same
content.

Globally unique names are not necessary for the functioning of package
universes.  Instead, names can be short and easily manageable by
humans.  Debian shows that short human-readable names, names that do
not, for example, include embedded DNS hostnames, are practical for
libraries at least as large as 10,000 packages.

The single universe-wide scope is intended designed to support a
person's workspace. It is not a suggestion or endorsement that the
packages themselves should refer to each other via the universe-wide
names.  Instead, it is intended to allow a human user a terse name for
each package in their local library, thereby supporting creative
development.


Packages can depend on each other.  The dependencies of a package are
listed by name, for example, ``Celeste 1.4 depends on HTML-Parser,''
with no version specified for the depended-on package.  More refined
dependency systems are possible and can be outlined in the full
version of the paper, but this approach appears sufficient for
practical usage.  The sufficiency of such a simple dependency system
follows from the fundamental design decision that each universe
includes a limited set of carefully chosen packages.  Because of this
design, software can simply select the newest version of any needed
package without needing to select among a large number of versions.

This simple versioning approach does not encompass version changes
that break intentionally compatibility.  Instead, the package names
must be made different, so that the universes software can distinguish
the mutually incompatible package versions.  For example, if ``libc
version 5.100'' and ``libc version 6.101'' break compatibility, then
they could be considered separate packages by naming them ``libc5
version 100'' and ``libc6 version 101.''


Version numbers must be totally ordered.  Simple integers suffice as
version numbers, as do hierarchical version numbers such as
``2.3.54c.''  The software support has a strong bias towards
downloading and installing the most recent available versions of
requested packages.  Thus, the version numbers must be totally ordered
so that the software can always decide which versions of a set of
versions is the most preferable.




\section{Policy Neutrality}

Security policies are supported by providing an interface to
primitive universes based on \emph{capabilities} \cite{miller00:caps}.
Universe servers on the network only allow operations when the
requestor presents a sufficient capability to use that request.  The
servers themselves do not use usernames and passwords nor any other
from of access-control lists.

Capabilities can be implemented as unguessably large random numbers.
Holding a capability is then equivalent to knowing the large number
associated with the capability.  A capability can be transmitted to a
user (or to a software object) by sending him or her the number.  If a
capability is revoked on a server, then all holders of that capability
lose the authority associated with that capability.


Primitive universe servers respond to capabilities designating the
following operations:
\begin{enumerate}
\item Download the list of package descriptions.
\item Upload a new package description.
\item Remove an existing package description.
\item Create a new capability of the first three kinds.
\item Revoke a capability of the first three kinds.
\end{enumerate}
The second and third capabilities could be subdivided in a mature
implementation to allow access to packages only of a specific name,
but in the relatively congenial communities envisioned, such
fine-grained control may be more of a burden than a help.


The final two capabilities are useful for implementing security
policies.  Different users can be given different capabilities for the
same operations.  Fine-grained security policies can then be implemented by
selectively creating and revoking individual capabilities.  Revoking
the capability held by one user, for example, does not affect other
capabilities held by other users.
Capabilities-based authorization provide sufficient control to
implement useful policies, several of which are described in the next
section.


Specific software support for individual policies is not required.
Whoever holds the capability-creation and capability-revocation
capabilities can create and remove capabilities at will.  Capabilities
can be transferred to users via simple email.  Thus, the capabilities
approach allows ad hoc policies to be defined without needing to write
any code.

On the other hand, it is also possible to write additional code to use
an existing user database and permissions system.  A program can
authenticate users and check whether they have permission to access
the package universe.  If that program is given the
capability-creation and -revocation capabilities for a particular
universe, then it can give out temporary capabilities to users in the
existing user database.

  
\section{Example Configurations}
The package universes architecture allows convenient implementation of
a variety of community organizations and software-engineering
processes.
\begin{itemize}
\item No restrictions.  Wikis have proven that effective and useful
      communities can be built even with no security restrictions at
      all.  This policy can be implemented by posting all of the
      universe's capabilities on a public web page.

\item Full access, but only to community members.  Many open-source
      projects have an organization of this form, including Debian's
      ``Debian Developers'' and FreeBSD's ``committers.''  This policy
      can be implemented by giving the capability-creation and
      -revocation capabilities to the membership gatekeepers.
      The last step of admitting a new member to the community is to
      give them their own capabilities to manipulate the community
      universes.

\item Single provider, multiple users.  An individual developer wants
      to provide a suite of packages to be used by a larger
      community---possibly the world, or possibly a limited base of
      subscribers.  To implement this policy, the developer can keep a
      universe's package-adding capabilities for personal use but
      publish the universe-retrieval capability to the desired
      user base.

\item Moderation queues.  Sometimes it is desirable to have a large
      community contribute suggested packages, but a smaller group to
      decide on what is actually included.  A moderation queue can be
      implemented as a separate universe where the package-addition
      capability is made available to whichever community is allowed
      to contribute suggestions (perhaps the entire world).
      Moderators would have both a reading capability for the
      moderation queue and a package-adding capability for the main
      universe, and could copy packages from the queue to the main
      universe whenever they are deemed appropriate.


\item Private local development.  Individual groups can form their own
      universe for private development without needing to coordinate
      with any central organization.  They simply create the universe
      and share keys with members of the group according to their
      own local security policy.

\item Public libraries plus local development.  The above organization
      can be refined by allowing developers to use publicly
      available packages even as they develop packages for private
      use.  This policy can be implemented by taking the union of the
      local universe with one ore more public universes.


\item Localized versions of packages.  Local groups may want to use
      something similar to a widely-scoped universe, but override
      specific packages with localized versions.  A particular example
      is language-specific versions of packages.  Users want to use
      the localized version of a package whenever one is available,
      but the global version otherwise.  This policy is implemented by
      creating a universe holding the localized packages, and then
      having users operate in the name-based union of this universe
      with the public one.

\item Stable versus unstable streams.  Projects frequently distinguish
      between stable and unstable streams of development.  The stable
      streams include packages that are heavily tested and deemed to
      be reliable, while the unstable streams include packages that
      are more current and featureful but are not as reliable.  A
      project can implement this policy by having separate universes
      for each development stream.  

\item Freezing new stable distributions.  A common process for
      generating stable distributions of code is to take an unstable
      stream, start testing it, and disallow any patches except for
      bug fixes.
%CITE can i find anything no this?
      After some
      point, the distribution is \emph{frozen} and considered a stable
      release.  Such processes can be implemented by manipulating the
      outstanding capabilities as time passes.  The testing phase can
      be implemented by revoking all outstanding add-package
      capabilities and switching over to a moderation queue process.  The
      actual freeze can be implemented by destroying the moderation
      queue and revoking the remaining add-package capabilities.  The
      frozen universe can then be duplicated, with one fork hosting
      a new development stream while the other becomes is designated
      a stable release.
\end{itemize}


\section{Experience}
\subsection{Squeak Implementation}
An early version of the architecture has been implemented in Squeak.
The early version had one major difference from the architecture
described in this paper.  It used a different security infrastructure
based on usernames, passwords, and an object that stood in for an
access control list.  This approach proved more cumbersome than
useful, thus leading to a reconsideration of the security approach.

The implementation was completed quickly.  It required 2 days
for the initial implementation, while refinements including an
improved user interface and a firewall-compatible networking approach
were completed in 3 more days of work.


\subsection{Stable Squeak 3.7}
The implementation in Squeak shows that no practical implementation
details have been been overlooked in the theory, but says nothing
about whether the tool is a practical part of a community's
infrastructure.  To address this question, the tool was used to develop
a stable distribution of packages that load into Squeak 3.7.  The
process was based on the ``freezing'' process described above.  The
result is a collection of 200 packages that are reliably loadable into
Squeak 3.7.
To the author's knowledge, this is the largest such distribution for
Squeak to date where all of the packages are loadable.


\subsection{Scala Bazaar}
The Scala community currently lacks infrastructure for conveniently
sharing source code packages contributed by the user base.  The
community is exploring using package universes for that role.

\emph{REVIEWERS:} Given the speed of the Squeak-based
implementation, we hope to have a Scala implementation completed by the
camera-ready deadline.

\bibliography{c5.bib}

\end{document}

% LocalWords:  SqueakMap Wikis formatter Etoys libc DNS hostnames requestor hoc
% LocalWords:  usernames unguessably proven FreeBSD's committers FreeBSD
% LocalWords:  featureful SuperSwikis versioning
