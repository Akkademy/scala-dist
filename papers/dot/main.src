\documentclass{llncs}

%\setlength{\textheight}{23cm}
\setlength{\textwidth}{13.5cm}
\advance\evensidemargin by -.65cm
\advance\oddsidemargin by -.65cm
%\setlength{\hoffset}{-1cm}
%\renewcommand{\baselinestretch}{0.95}

%\setlength{\abovedisplayskip}{3pt plus 0pt minus 0pt}
%\setlength{\abovedisplayskip}{3pt}
%\setlength{\abovedisplayshortskip}{3pt}
%\setlength{\belowdisplayskip}{3pt}
%\setlength{\belowdisplayshortskip}{3pt}

\usepackage{fleqn}
\usepackage{math}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage[scaled=0.848971]{luximono} % This is for 11 pt Default font
\usepackage[T1]{fontenc}

% Prooftree formatting
\usepackage{prooftree}

% support for generating PDF files
\newif\ifpdf
    \ifx\pdfoutput\undefined
    \pdffalse
\else
    \pdftrue
    \pdfoutput=1
\fi

%versions
% for technical reports, set \iflong and \ifreport to true
\newif\iflong\longtrue
\newif\ifshort\shortfalse
\newif\ifreport\reportfalse

%% set latex/pdflatex specific stuff
\ifpdf
    \usepackage[pdftex,
                hyperindex,
                plainpages=false,
                breaklinks,
                colorlinks,
                citecolor=black,
                filecolor=black,
                linkcolor=black,
                pagecolor=black,
                urlcolor=black]{hyperref}
    \usepackage[pdftex]{graphicx}
    \DeclareGraphicsExtensions{.jpg,.pdf}
    \pdfcatalog {
        /PageMode (/UseNone)
    }
    \usepackage{thumbpdf}
    \usepackage[pdftex]{color}
\else
    \usepackage[ps2pdf]{hyperref}
    \usepackage{graphicx}
    \DeclareGraphicsExtensions{.eps,.jpg}
    \usepackage{color}
\fi

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{5pt}

% verbfilter stuff
\newcommand{\prog}[1]{{\sl #1}}
\newenvironment{program}[1][10.5]
  {\fontsize{#1}{13.6}\tt\begin{tabbing}\hspace*{0.5\parindent}\=\+\kill}
  {\end{tabbing}\noindent}
\newcommand{\blockcomment}[1]{{\color{grayPoint3}#1}}
\newcommand{\linecomment}{\color{grayPoint3}}
\newcommand{\grey}{\color{grey}}

%\newenvironment{program}{\ \ \ \ \begin{minipage}{\textwidth}\renewcommand{\baselinestretch}{1.0}\sl\begin{tabbing}}{\end{tabbing}\end{minipage}}
\newcommand{\vem}{\bfseries}
\newcommand{\quotedstring}[1]{{#1}}
\newcommand{\typename}[1]{{#1}}
\newcommand{\literal}[1]{{#1}}

% comments and notes
\newcommand{\comment}[1]{}
%\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

% figures
\newcommand{\figurebox}[1]
        {\fbox{\begin{minipage}{\textwidth} #1 \medskip\end{minipage}}}
\newcommand{\twofig}[3]
        {\begin{figure*}[t]#3\ \hrulefill\ 
        \caption{\label{#1}#2}\end{figure*}}
\newcommand{\boxfig}[3]
        {\begin{figure*}\figurebox{#3\caption{\label{#1}#2}}\end{figure*}}
\newcommand{\figref}[1]
        {Figure~\ref{#1}}

% typing rules (not used here)
\newcommand{\ttag}[1]{\mbox{\textsc{\small(#1)}}}
\newcommand{\infer}[3]{\mbox{#1 }\ba{c} #2 \\ \hline #3 \ea}
\newcommand{\irule}[2]{{\renewcommand{\arraystretch}{1.2}\ba{c} #1 
                        \\ \hline #2 \ea}}
\newlength{\trulemargin}
\newlength{\trulewidth}
\newlength{\srulewidth}
\setlength{\trulemargin}{1.75cm}
\setlength{\trulewidth}{83.7mm}
\setlength{\srulewidth}{6.0cm}
\newenvironment{trules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\trulewidth}@{~}p{\trulemargin}}}{\ea$}
\newenvironment{srules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\srulewidth}}}{\ea$}
\newcommand{\laxiom}[2]{\ttag{#1} & $ #2 \hfill\ }
\newcommand{\raxiom}[2]{\hfill #2 $& \hfill \ttag{#1}}
\newcommand{\caxiom}[2]{\ttag{#1} & $\hfill #2 \hfill $& \ }
\newcommand{\lrule}[3]{\laxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rrule}[3]{\raxiom{#1}{\irule{#2}{#3}}}
\newcommand{\crule}[3]{\caxiom{#1}{\irule{#2}{#3}}}
\newcommand{\lsrule}[3]{\lsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rsrule}[3]{\rsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\nl}{\end{trules}\\[0.5em] \begin{trules}}
\newcommand{\snl}{\end{srules}\\[0.5em] \begin{srules}}

% commas and semicolons
\newcommand{\comma}{,\,}
\newcommand{\commadots}{\comma \ldots \comma}
\newcommand{\semi}{;\mbox{;};}
\newcommand{\semidots}{\semi \ldots \semi}

% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

% math stuff
\newenvironment{myproof}{{\em Proof:}}{$\Box$}
\renewenvironment{proofsketch}{{\em Proof Sketch:}}{$\Box$}
\newcommand{\Case}{{\em Case\ }}

% make ; a delimiter in math mode
% \mathcode`\;="8000 % Makes ; active in math mode
% {\catcode`\;=\active \gdef;{\;}}
% \mathchardef\semicolon="003B

% reserved words
\newcommand{\mathem}{\bf}

% brackets
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sbs}[1]{\lquote #1 \rquote}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}

% \cal ids
\renewcommand{\AA}{{\cal A}}
\newcommand{\BB}{{\cal B}}
\newcommand{\CC}{{\cal C}}
\newcommand{\DD}{{\cal D}}
\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\GG}{{\cal G}}
\newcommand{\HH}{{\cal H}}
\newcommand{\II}{{\cal I}}
\newcommand{\JJ}{{\cal J}}
\newcommand{\KK}{{\cal K}}
\newcommand{\LL}{{\cal L}}
\newcommand{\MM}{{\cal M}}
\newcommand{\NN}{{\cal N}}
\newcommand{\OO}{{\cal O}}
\newcommand{\PP}{{\cal P}}
\newcommand{\QQ}{{\cal Q}}
\newcommand{\RR}{{\cal R}}
\newcommand{\TT}{{\cal T}}
\newcommand{\UU}{{\cal U}}
\newcommand{\VV}{{\cal V}}
\newcommand{\WW}{{\cal W}}
\newcommand{\XX}{{\cal X}}
\newcommand{\YY}{{\cal Y}}
\newcommand{\ZZ}{{\cal Z}}

% misc symbols
\newcommand{\dhd}{\!\!\!\!\!\rightarrow}
\newcommand{\Dhd}{\!\!\!\!\!\Rightarrow}
\renewcommand{\ts}{\,\vdash\,}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\eg}{{\em e.g.}}

% misc identifiers
\newcommand{\dom}{\mbox{\sl dom}}
\newcommand{\fn}{\mbox{\sl fn}}
\newcommand{\bn}{\mbox{\sl bn}}
\newcommand{\sig}{\mbox{\sl sig}}
\newcommand{\IF}{\mbox{\mathem if}}
\newcommand{\OTHERWISE}{\mbox{\mathem otherwise}}
\newcommand{\strongexpand}{\prec\!\!\prec}
\newcommand{\weakexpand}{\prec}
\newcommand{\spcomma}{~,~}

%\newcommand{\inst}{\mbox{\mathem inst}}
\newcommand{\trans}[1]{\la\!\la#1\ra\!\ra}
\newcommand{\todo}[1]{\note{to do: #1}}
%\newcommand{\J}{\justifies}
%\newcommand{\U}{\using}

% names
\newcommand{\Scala}{\mbox{\textsc{Scala}}}
\newcommand{\Java}{\mbox{\textsc{Java}}}

%\renewcommand\textfraction{.05}
%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Language abstraction commands     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Relations
% Subtype 
\newcommand{\sub}{<:}
% Type assignment
\newcommand{\typ}{:}
\newcommand{\pathtyp}{::}
% reduction
\newcommand{\reduces}{\;\rightarrow\;}
% well-formedness
\newcommand{\wf}{\;\mbox{\textbf{wf}}}

%% Operators
% Type selection
\newcommand{\tsel}{\#}
% Function type
\newcommand{\tfun}{\rightarrow}
% Conjunction
\newcommand{\tand}{\wedge}
% Disjunction
\newcommand{\tor}{\vee}
% Singleton type suffix
\newcommand{\sing}{.\textbf{type}}

%% Syntax
% Header for typing rules
\newcommand{\judgement}[2]{{\bf #1} \hfill \fbox{#2}}
% Refinement
\newcommand{\refine}[2]{\left\{#1 \Rightarrow #2 \right\}}
% Field definitions
\newcommand{\ldefs}[1]{\left\{#1\right\}}
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}
% Lambda
\newcommand{\abs}[3]{\lambda #1\!:\!#2.#3}
% Application
\newcommand{\app}[2]{#1\;#2}
% Substitution
\newcommand{\subst}[3]{[#1/#2]#3}
% Object creation
\newcommand{\new}[3]{\textbf{val }#1 = \textbf{new }#2 ;\; #3}
%\renewcommand{\new}[3]{#1 \leftarrow #2 \,\textbf{in}\, #3}
% Field declaration
\newcommand{\Ldecl}[3]{#1 \typ #2..#3}%{#1 \operatorname{>:} #2 \operatorname{<:} #3}
\newcommand{\ldecl}[2]{#1 \typ #2}
% Top and Bottom
\newcommand{\Top}{\top}%{\textbf{Top}}
\newcommand{\Bot}{\bot}%\textbf{Bot}}
% Environment extension
\newcommand{\envplus}[1]{\uplus \{ #1 \}}
% Reduction
\newcommand{\reduction}[4]{#1 \operatorname{|} #2 \reduces #3 \operatorname{|} #4}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% BEGIN DOCUMENT %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\thispagestyle{plain}
\pagestyle{plain}
\mainmatter

\title{Dependent Object Types - A foundation for Scala's type system
  \\ \ \\ \large Draft of \today\ -- Do Not Distrubute}
\author{Martin Odersky, Geoffrey Alan Washburn}
\institute{EPFL}

\maketitle
\sloppy
\newcommand{\lindent}{\hspace{-4mm}}

\begin{abstract}
\end{abstract}

%\fontfamily{timesroman}
\section{Introduction}

This paper presents a proposal for a new type-theoretic foundation of
Scala and languages like it. The properties we are interested in
modelling are Scala's path-dependent types and abstract type members,
as well as its mixture of nominal and structural typing through the
use of refinement types. Compared to previous approaches (nuObj, FS),
we make no attempt to model inheritance or mixin composition. Indeed
we will argue that such concepts are better modelled in a different
setting.

The calculus does not precisely describe what's currently in Scala. It
is more normative than descriptive. The main point of deviation
concerns the difference between Scala's compound type formation using
{\bf with} and classical type intersection, as it is modelled in the
calculus. Scala, and the previous calculi attempting to model it
conflates the concepts of compound types (which inherit the members of
several parent types) and mixin composition (which build classes from
other classes and traits). At first glance, this offers an economy of
concepts. However, it is problematic because mixin composition and
intersection types have quite different properties. In the case of
several inherited members with the same name, mixin composition has to
pick one which overrides the others. It uses for that the concept of
linearization of a trait hierarchy. Typically, given two independent
traits $T_1$ and $T_2$ with a common method $m$, the mixin composition
\@$T_1$ with $T_2$@ would pick the $m$ in $T_2$, whereas the member in
$T_1$ would be available via a super-call. All this makes sense from
an implementation standpoint. From a typing standpoint it is more
awkward, because it breaks commutativity and with it several
monotonicity properties.

In the present calculus, we replace Scala's compound types by
classical intersection types, which are commutative. We also
complement this by classical union types. Intersections and unions
form a lattice wrt subtyping. This addresses another problematic
feature of Scala: In Scala's current type system, least upper bounds
and greatest lower bounds do not always exist. Here is an example:
Given two traits
@@
  trait A { type T <: A }
  trait B { type T <: B }
@@
The greatest lower bound of \@A@ and \@B@ is approximated by the
infinite sequence
@@
  A with B { type T <: A with B { type T <: A with B { type T < ... }}}
@@
The limit of this sequence does not exist as a type in Scala.

This is problematic because glbs and lubs play a central role in
Scala's type inference. The absence of universal glbs and lubs makes
type inference more brittle and more unpredictable.

\subsection*{Why No Inheritance?}

In the calculus we made the deliberate choice not to model any form of
inheritance. This is, first and foremost, to keep the calculus simple.
Secondly, there are so many different approaches to inheritance and
mixin composition, so that it looks advantageous not to tie the basic
calculus to a specific one. Finally, it seems that the modelization of
inheritance lends itself to a different approach than the basic
calculus. For the latter, we need to prove the standard theorems of
preservation and progress to establish soundness of the type system.
One might try to do this also for a calculus with inheritance, but our
experience suggests that this complicates the proofs considerably.  An
alternate approach to inheritance that might work better is to model
it as a form of code-reuse. Starting with an enriched type system with
inheritance, and a translation to the basic calculus, one needs to
show type preservation wrt the translation. This might be easier than
to prove type preservation wrt reduction.


\section{The DOT Calculus}

\begin{figure}
\figurebox{
%\renewcommand{\baselinestretch}{0.95}
{\bf Syntax}\medskip
    
$\ba{l@{\hspace{2mm}}|@{\hspace{2mm}}l}
\ba[t]{l@{\hspace{10mm}}l}
x, y, z    & \lindent{\mbox{Variable}} \\
l          & \lindent{\mbox{Value label}}\\[0.2em]
v ::=      & \lindent{\mbox{Value}} \\
\gap x     & \mbox{variable} \\
\gap \abs x T t & \mbox{function} \\[0.2em]
t ::=      & \lindent{\mbox{Term}} \\
\gap v     & \mbox{value} \\
\gap \app t t  & \mbox{application} \\
\gap \new x c t & \mbox{new instance} \\
\gap t.l  & \mbox{selection} \\[0.2em]
p ::= & \lindent \mbox{Path} \\
\gap x & \mbox{variable} \\
\gap p.l & \mbox{selection} \\
c ::= T_c \ldefs{\seq{l = v}} & \lindent{\mbox{Constructor}} \\[0.2em]
\Gamma ::= \seq{x \typ T} & \lindent\mbox{Environment} \\
s      ::= \seq{x \mapsto c} & \lindent\mbox{Store} \\
\ea
&
\ba[t]{l@{\hspace{10mm}}l}
L ::=      & \lindent{\mbox{Type label}} \\
\gap L_c   & \mbox{class label} \\
\gap L_a   & \mbox{abstract type label} \\[0.2em]
S,T,U,V  ::= & \lindent\mbox{Type}\\
\gap p.L & \mbox{type selection} \\
\gap T \refine z {\seq D} & \mbox{refinement type} \\
\gap T \tfun T & \mbox{function type} \\
\gap T \tand T & \mbox{intersection type} \\
\gap T \tor T & \mbox{union type} \\
\gap \Top  & \mbox{top type} \\
\gap \Bot  & \mbox{bottom type} \\[0.2em]
S_c, T_c ::= & \lindent \mbox{Concrete type} \\
\multicolumn{2}{l}{\gap p.L_c ~|~ \Top ~|~ T_c \wedge T_c ~|~ T_c \refine z {\seq D}} \\[0.2em] 
D ::= & \lindent\mbox{Declaration} \\
\gap \Ldecl L S U & \mbox{type declaration} \\
\gap \ldecl l T   & \mbox{value declaration}
\ea
\ea$
\medskip

\linesep

\begin{multicols}{2}[\judgement{Reduction}{$\reduction t s {t'} {s'}$}]

\infax[$\beta_v$]
{\reduction {(\app{\abs x T t}){v}} s {\subst v x t} s}

\infrule[\textsc{sel}]
{x \mapsto T_c \ldefs{\seq{l = v}} \in s}
{\reduction {x.l_i} s {v_i} s}

\infax[\textsc{new}]
{\reduction {\new x c t} s t {s \envplus{x \mapsto c}}}

\infrule[\textsc{context}]
{\reduction t s {t'} {s'}}
{\reduction {e[t]} s {e[t']} s'}
\end{multicols}

\hfill {\bf where} evaluation context $\gap e ::= [\,] ~|~ \app e t ~|~ \app v e ~|~ e.l ~|~ \new x c e$

\linesep

\begin{multicols}{2}[\judgement{Type Assignment}{$\Gamma \ts t \typ T$}]

\infrule[\textsc{var}]
{x \typ T \in \Gamma}
{\Gamma \ts x \typ T}

\infrule[\textsc{abs}]
{x \notin \fn(T') \andalso \Gamma \ts T \wf \\
 \Gamma \envplus{x \typ T} \ts t: T'}
{\Gamma \ts \abs x T t \typ T \tfun T'}

\infrule[\textsc{app}]
{\Gamma \ts t \typ  T' \tfun T \spcomma t' \typ T'}
{\Gamma \ts \app t {t'} \typ T}

\infrule[\textsc{sub}]
{\Gamma \ts t \typ T \spcomma T \sub U}
{\Gamma \ts t \typ U}

\infrule[\textsc{sel}]
{\Gamma \ts t \ni l \typ T'}
{\Gamma \ts t.l \typ T'}

\infrule[\textsc{new}]
{x \notin \fn(T') \andalso \Gamma \ts T_c \wf \\
T_c \strongexpand_x \seq{\Ldecl {L_c} {\Bot} {U_c}},\seq{\Ldecl {L_a} {S_c} {S_c}},\seq{\ldecl l V} \\
 \Gamma \envplus{x: T_c} \ts \seq{v \typ V} \spcomma t \typ T'}
{\Gamma \ts \new x {T_c \ldefs{\seq{l = v}}} t \typ T'}
\end{multicols}

\linesep
\begin{multicols}{2}[\judgement{Path Type Assignment}{$\Gamma \ts p
    \pathtyp T$}]
\infrule[\textsc{var-p}]
{x \typ T \in \Gamma}
{\Gamma \ts x \pathtyp T}

\infrule[\textsc{sel-p}]
{\Gamma \ts p \ni l \typ T'}
{\Gamma \ts p.l \pathtyp T'}
\end{multicols}

}

\caption{The DOT Calculus : Syntax, Reduction, Type Assignment}\label{dot-one}
\end{figure}

The DOT calculus is a simple system of dependent
object-types. Figure~\ref{dot-one} gives its syntax, reduction rules,
and type assignment rules.

\subsection*{Notation} We use standard notational conventions for sets. The notation $\seq{X}$ denotes a set of elements $X$. Given a such a set $\seq X$ in a typing rule, $X_i$ denotes an arbitrary element of $X$. The $\uplus$ operator extends a set of bindings. It is required that the added binding does not
introduce a variable which is already bound in the base-set. We use an
abbreviation for preconditions in typing judgements. Given an
environment $\Gamma$ and some predicates $P$ and $Q$, the condition $\Gamma \ts P \spcomma Q$
is a shorthand for the two conditions $\Gamma \ts P$ and $\Gamma \ts Q$.

\subsection*{Syntax}

There are three alphabets: Variable names $x$, $y$, $z$ are freely
alpha-renamable. They occur as parameters of lambda abstractions, as
binders for objects created by \verb@new@-expressions, and as self
references in refinements. Value labels $l$ denote fields in objects,
which are bound to values at run-time. Type labels $L$ denote type
members of objects. Type labels are further separated into labels for
abstract types $L_a$ and labels for classes $L_c$. It is assumed that
in each program every class label $L_c$ is declared at most once.

The terms $t$ in DOT consist of variables $x$, $y$, $z$, lambda
abstractions $\abs x T t$, function applications $\app t {t'}$, field
selections $t.l$, and object creation expressions $\new x c t$ where
$c$ is a constructor $T_c \ldefs{\seq{l = v}}$. The latter binds a
variable $x$ to a new instance of class $L_c$ with outer prefix $p$
and fields $\seq l$ initialized to values $\seq v$.  The scope of $x$ extends through the term $t$.

Two subclasses of terms are values $v$, which consist of just
variables and lambda abstractions, and paths $v$ which consist of just
variables and selections.

The types in DOT are denoted by letters $S$, $T$, $U$, or $V$. They consist of the following:
\begin{itemize}
\item[-] Type selections $p.L$, which denote the type member $L$ of path $p$.
%         A shorthand notation applies to type selections on singleton types: Instead
%         of $p \sing \tsel L$ one can write just $p.L$.
\item[-] Refinement types $T \refine z {\seq D}$, which refine a type $T$ by a set of declarations $D$.
         The variable $z$ refers to the ``self''-reference of the type. Declarations can refer to
         other declarations in the same type by selecting from $z$.
\item[-] Function types $T \tfun T'$.
\item[-] Type intersections $T \tand T'$, which carry the declarations of members present in either $T$ or $T'$.
\item[-] Type unions $T \tor T'$, which carry only the declarations of members present in both $T$ and $T'$.
\item[-] A top type $\Top$, which corresponds to an empty object.
\item[-] A bottom type $\Bot$, which represents a non-terminating computation.
\end{itemize}
A subset of types $T_c$ are called {\em concrete types}. These are type selections
$p.L_c$ of class labels,
the top type $\Top$, intersections of concrete types, and refinements $T_c \refine z {\seq D}$ of concrete types. Only concrete types are allowed in constructors $c$.

%Types in DOT form a lattice where $\tand$ is join and $\tor$ is meet. 

There are only two forms of declarations in DOT, which are both part
of refinement types.  A value declaration $\ldecl l T$ introduces a
field with type $T$.  A type declaration $\Ldecl L S U$ introduces a
type member $L$ with a lower bound type $S$ and an upper bound type
$U$. There are no type aliases, but a type alias can be simulated by a
type declaration $\Ldecl L T T$ where the lower bound and the upper
bound are the same type $T$. 

%It is assumed that the lower bound of
%every class type is the bottom type and that the upper bound is a
%concrete type. That is, the only permissible form of a class
%declaration is $\Ldecl {L_c} \Bot T_c$.

Every field or type label can be declared only once in a set of
declarations. A set of declarations can hence be seen as a map from
labels to their declarations.  Intersection and union on sets of
declarations are defined as follows.  

\bda{lcl@{\gap}l}
    
      \dom(\seq D \tand \seq {D'}) &~=~& \dom(\seq{D}) \cup \dom(\seq{D'}) \\
      \dom(\seq D \tor \seq {D'}) &=& \dom(\seq{D}) \cap \dom(\seq{D'}) \\[0.5em]
      (D \tand D')(L) &=&
        \Ldecl L {(S \tor S')} {(U \tand U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
        &=& D(L) & \mbox{if~} L \notin \dom(\seq{D'}) \\
        &=& D'(L) & \mbox{if~} L \notin \dom(\seq{D}) \\
      (D \tand D')(l) &=&
        \ldecl l {T \tand T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} \\
        &=& D(l) & \mbox{if~} l \notin \dom(\seq{D'}) \\
        &=& D'(l) & \mbox{if~} l \notin \dom(\seq{D}) \\[0.5em]
      (D \tor D')(L) &=&
        \Ldecl L {(S \tand S')} {(U \tor U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(l) &=&
        \ldecl l {T \tor T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} 
    \eda

\subsection*{Reduction rules}

Reduction rules $\reduction t s {t'} {s'}$ in DOT rewrite pairs of
terms $t$ and stores $s$, where stores map variables to constructors.
There are three main reduction rules: ($\beta_V$) is the standard beta
reduction of call-by-value lambda calculus. Rule (\textsc{new}) rewrites an
object creation $\new x c t$ by placing the binding of variable $x$ 
to constructor $c$ in the store and continuing with term $t$. Rule (\textsc{sel})
rewrites a field selection $x.l$ by retrieving the corresponding value from the store.
These reduction rules can be applied anywhere in a term where the hole $[\,]$ of 
an evaluation context $e$ can be situated. 

\subsection*{Type assignment rules}

The last part of Figure~\ref{dot-one} presents rules for type assignment.  The
three rules (\textsc{var}), (\textsc{abs}), and (\textsc{app}) on the left correspond to
simply typed lambda calculus (I believe it is straightforward to extend this to
System $F$). Rule (\textsc{abs}) has an additional precondition stating that the
bound variable $x$ may not appear in the function's result type $T'$. It would
be an interesting extension of the calculus to drop this precondition, thereby
allowing dependent function types.

Rule rule (\textsc{sub}) is the standard subsumption rule for subtyping.

%The (\textsc{path}) rule gives the alternate type $p \sing$ to a well-typed path
%$p$ whose type $T$ has a non-empty expansion $D,\seq{D}$.  By the subtyping rule
%(\textsc{single-$\sub$}) in Figure~\ref{dot-sub}, the alternate type $p \sing$
%is guaranteed to be a subtype of the underlying type $T$ of $p$.

Rule (\textsc{sel}) types a field selection by means of an auxiliary
membership relation $\ni$, which determines whether a given term contains a given
declaration as one of its members. The membership relation is defined in
Figure~\ref{dot-two} and is further explained below.

The last rule, (\textsc{new}), assigns types to object creation expressions. It
is the most complex of DOT's typing rules.  To type-check an object
creation $\new x {T_c \ldefs {\seq{l = v}}} t$, one verifies first
that the type $T_c$ is well-formed (see Figure~\ref{dot-wf} for a definition of
well-formedness).  One then determines the set of all declarations that this type
carries, using the strong expansion relation $\strongexpand$ defined in Figure~\ref{dot-two}. 
This set of declarations must be decomposable into declarations of the following
three forms:
\begin{enumerate}
\item
Class type declarations $\Ldecl {L_c} \Bot U_c$. The lower bound of every
declared class must be the bottom type $\bot$. The upper bound must be a
concrete type $U_c$.
\item
Abstract type aliases $\Ldecl {L_a} {S_c} {S_c}$. Every non-class type member
$L_a$ of $T_c$ must be defined as an alias of some
concrete type $S_c$.
\item
Field declarations $l: V$.
\end{enumerate}
One needs to verify that each field is given a  value $v$ which is of
the field's declared type $V$. This check is made in an
environment which is extended by the binding $x: T_c$. In particular
this allows field values that recurse on ``self'' by referring to the
bound variable $x$. As in the (\textsc{abs}) rule, it is required that
the bound variable does not appear in the expression's result type
$T'$.

A variant of the type assignment relation $\pathtyp$ is specialized to
paths. The judgement $\Gamma \ts p \pathtyp T$ states that $T$ is the
principal type of path $p$. The rules for path typing are the same as
for terms, except that subsumption via (\textsc{sub}) is not allowed.
\begin{figure}
  \figurebox{

    \begin{multicols}{2}[\judgement{Membership}{$\Gamma \ts t \ni D$}]

      \infrule[\textsc{term-$\ni$}]
      {\Gamma \ts t \typ T \spcomma T \weakexpand_z \seq D \andalso z \not\in \fn(\Gamma, T)}
      {\Gamma \ts t \ni D_i}

      \infrule[\textsc{path-$\ni$}]
      {\Gamma \ts p \pathtyp T \spcomma T \weakexpand_z \seq D \andalso z \not\in \fn(\Gamma)}
      {\Gamma \ts p \ni \subst p z {D_i}}

   \end{multicols}

   \linesep

    \begin{multicols}{2}[\judgement{Weak Expansion}{$\Gamma \ts T \weakexpand_z \seq D$}]

      \infrule[\textsc{tsel-$\weakexpand$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma U \weakexpand_z \seq D}
      {\Gamma \ts p.L \weakexpand_z \seq D}

    \infrule[\textsc{$\tand$-$\weakexpand$}]
      {\Gamma \ts T \weakexpand_z \seq D \spcomma T' \weakexpand_z \seq {D'}}
      {\Gamma \ts T \tand T' \weakexpand_z \seq D \tand \seq {D'}}

      \infrule[\textsc{$\Bot$-$\weakexpand$}]
      {\Gamma \envplus {z: \Bot} \ts \seq{D \wf}}
      {\Gamma \ts \Bot \weakexpand_z \seq D}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{refine-$\weakexpand$}]
              {\Gamma \ts T \weakexpand_z \seq {D'}}
              {\Gamma \ts T \refine z {\seq D} \weakexpand_z \seq {D'} \tand \seq D}

      \infrule[\textsc{$\tor$-$\weakexpand$}]
      {\Gamma \ts T \weakexpand_z \seq D \spcomma T' \weakexpand_z \seq {D'}}
      {\Gamma \ts T \tor T' \weakexpand_z \seq D \tor \seq {D'} \spcomma}

      \infax[\textsc{default-$\weakexpand$}]
      {\Gamma \ts T \weakexpand_z \{\}}

    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Strong Expansion}{$\Gamma \ts T_c \strongexpand_z \seq D$}]  

      \infrule[\textsc{tsel-$\strongexpand$}]
      {\Gamma \ts p \ni \Ldecl {L_c} \Bot U \spcomma U \strongexpand_z \seq D}
      {\Gamma \ts p.L_c \strongexpand_z \seq D}

      \infrule[\textsc{$\tand$-$\strongexpand$}]
      {\Gamma \ts T_c \strongexpand_z \seq D \spcomma T_c' \strongexpand_z \seq {D'}}
      {\Gamma \ts T_c \tand T_c' \strongexpand_z \seq D \tand \seq {D'}}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{refine-$\strongexpand$}]
      {\Gamma \ts T_c \strongexpand_z \seq {D'} \\
       \Gamma \envplus{x: \Top \refine x {\seq{D'} \oplus \seq D}} \ts
         \seq{D'} \oplus \seq D \sub \seq{D'}}
      {\Gamma \ts T_c \refine z {\seq D} \strongexpand_z \seq {D'} \oplus \seq D}

      \infax[\textsc{$\Top$-$\strongexpand$}]
      {\Gamma \ts \Top \strongexpand_z \{\}}
    \end{multicols}
 }
\caption{The DOT Calculus : Membership and Expansion}\label{dot-two}
\end{figure}


\subsection*{Membership}

Figure~\ref{dot-two} presents typing rules for membership and expansion.
The membership judgement $\Gamma \ts t \ni D$ states that in
environment $\Gamma$ a term $y$ has a declaration $D$ as a member.
Membership is built on (weak) expansion. There are two rules, one for general
terms and another one for just paths. 

The rule (\textsc{term-$\ni$}) for selections from general terms
states that a term $t$ of type $T$ has as member every declaration in
the expansion of $T$, as long as the self reference $z$ does not
appear free in the declaration. This requirement is dropped in the
second rule (\textsc{path-$\ni$}) for selection from paths. A path $p$
has as members all declarations in its expansion, where any use of the
self reference $z$ is replaced by the path $p$ itself. 

\subsection*{Weak Expansion}

The weak expansion judgement $\Gamma \ts T \weakexpand_z \seq D$ states that in
environment $\Gamma$ type $T$ carries member declarations which are ``at least as
good'' as those declared by the set $\seq{D}$, where $z$ denotes the
(alpha-renamable) self reference of type $T$. The rules are quite
straightforward:

Rule (\textsc{tsel-$\weakexpand$}) states that a type selection $p.L$
carries the same declarations as the upper bound $U$ of $L$
in $T$.  
Rule (\textsc{refine-$\weakexpand$}) states that a refinement
type $T \refine z {\seq{D}}$ carries the meet $\wedge$ of the
expansion of $T$ and $\seq{D}$, i.e.\ the least set of declarations that subsumes
both the expansion of $T$ and $\seq{D}$.  
Rules (\textsc{$\tand$-$\weakexpand$}) and
(\textsc{$\tor$-$\weakexpand$}) state that expansion distributes through
meets and joins. 
Rule (\textsc{$\Bot$-$\weakexpand$}) states that the
bottom type carries an arbitrary set of well-formed declarations. 
Rule (\textsc{default-$\weakexpand$}) states that every type carries at
least the empty set of declarations.

A different expansion rule for the bottom type might be envisioned:

      \infax[\textsc{$\Bot$-$\weakexpand$'}]
      {\Gamma \ts \Bot \weakexpand_z \{\}}

This alternate rule states that $\Bot$ carries {\em no} declarations. It
would be useful from a type-checking perspective, because it prevents
unreachable code, i.e.\ selections on terms that are known to
diverge. As a downside, the alternate rule would introduce a
non-regularity in the calculus. With the rules as given in Figure~\ref{dot-two} 
it holds that subtypes always have richer expansions than their supertypes. Replacing 
(\textsc{$\Bot$-$\weakexpand$}) by (\textsc{$\Bot$-$\weakexpand$'}) would break that property.

\subsection*{Strong Expansion}

Weak expansion is nondeterministic: Given an environment $\Gamma$ and a type
$T$, there are in general several sets of declarations $\seq{D}$ such that
$\Gamma \ts T \weakexpand_z \seq D$. We also need a stronger, deterministic
relation that tells us exactly what declarations a type carries. This relation,
called {\em strong expansion} and written $\strongexpand$, is needed to
typecheck the complete set of declarations of a concrete type that is used in a
\textbf{new}-expression.  Since this is the only place where strong expansion is needed,
it is sufficient to define it on concrete types only. The bottom part of
Figure~\ref{dot-two} gives the typing rules for strong expansion.  Compared to
the rules for weak expansion, one notes the following differences:
\begin{enumerate}
\item
Strong expansion of singleton types is handled by two new rules:
(\textsc{var-$\strongexpand$}) and (\textsc{psel-$\strongexpand$}). The rules
avoid reference to type assignment, and with it the non-determinism
introduced by the subsumption rule (\textsc{sub}).
\item
There's a new interpretation of strong expansion of refinement types $T_c
\refine z {\seq D}$, as defined by rule (\textsc{refine-$\strongexpand$}).
Whereas the weak expansion of such a refinement type yields the meet $\seq{D'}
\wedge \seq{D}$ of the expansion $\seq{D'}$ of $T$ and the newly defined members
$\seq D$, the strong expansion yields the right-replacing merge $\seq{D'} \oplus
\seq{D}$. In this merge, a declaration in $\seq{D}$ replaces a declaration of the
same label in $\seq{D'}$. Furthermore, the preconditon of rule
(\textsc{refine-$\strongexpand$}) checks that the resulting declarations subsume
the declarations coming from type $T_c$, where declaration subsumption
$\sub$ is defined in Figure~\ref{dot-sub}. Intuitively, a refinement type has a strong
expansion only if every declaration in the refinement which masks a declaration
in the base type is ``at least as good'' as that masked declaration.
\item
The default rule, which assigns every type an empty expansion, is dropped.
At its place is rule (\textsc{$\top$-$\strongexpand$}) which lets the top type $\top$
strongly expand to the empty set.
\end{enumerate}

\begin{figure}
  \figurebox{

    \begin{multicols}{2}[\judgement{Subtyping}{$\Gamma \ts S \sub T$}]

      \infax[\textsc{refl}]
      {\Gamma \ts T \sub T}

      \infrule[\textsc{$\sub$-$\tfun$}]
      {\Gamma \ts T \sub S \spcomma S' \sub T'}
      {\Gamma \ts S \tfun S' \sub T \tfun T'}

      \infax[\textsc{refine-$\sub$}]
      {\Gamma \ts T \refine z {\seq D} \sub T}

      \infrule[\textsc{tsel-$\sub$}]
      {\Gamma \ts p \ni \Ldecl L S U}
      {\Gamma \ts p.L \sub U}

      \infax[\textsc{$\tand$-$\sub$}]
      {\Gamma \ts T \tand T' \sub T \\ 
        \Gamma \ts T \tand T' \sub T'}

      \infrule[\textsc{$\tor$-$\sub$}]
      {\Gamma \ts S \sub T \spcomma S' \sub T}
      {\Gamma \ts S \tor S' \sub T}

      \infax[\textsc{$\Bot$-$\sub$}]
      {\Gamma \ts \Bot \sub T}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{trans}]
      {\Gamma \ts S \sub T \spcomma T \sub U}
      {\Gamma \ts S \sub U}

      \infrule[\textsc{$\sub$-refine}]
      {\Gamma \ts S \sub T \spcomma S \weakexpand_z \seq{D'} \\
       \Gamma \envplus{z: S} \ts \seq{D'} <: \seq{D}}
      {\Gamma \ts S \sub T \refine z {\seq D}}

      \infrule[\textsc{$\sub$-tsel}]
      {\Gamma \ts p \ni \Ldecl L S U}
      {\Gamma \ts S \sub p.L}

      \infrule[\textsc{$\sub$-$\tand$}]
      {\Gamma \ts S \sub T \spcomma S \sub T'}
      {\Gamma \ts S \sub T \tand T'}

      \infax[\textsc{$\sub$-$\tor$}]
      {\Gamma \ts T \sub T \tor T' \\ \Gamma \ts T' \sub T \tor  T'}
      
      \infax[\textsc{$\sub$-$\Top$}]
      {\Gamma \ts T \sub \Top}
      
      \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Declaration subsumption}{$\Gamma \ts D \sub D'$}]

    \infrule[\textsc{tdecl-$\sub$}]
            {\Gamma \ts S' \sub S \spcomma T \sub T'}
            {\Gamma \ts (\Ldecl L S T) \sub (\Ldecl L {S'} {T'})}

    \infrule[\textsc{vdecl-$\sub$}]
            {\Gamma \ts T \sub T'}
            {\Gamma \ts (\ldecl l T) \sub (\ldecl l {T'})}

    \end{multicols}

  }

\caption{The DOT Calculus : Subtyping and Declaration Subsumption}\label{dot-sub}
\end{figure}


\subsection*{Subtyping}

Figure~\ref{dot-sub} defines the subtyping judgement $\Gamma \ts S \sub T$ which states that in
environment $\Gamma$ type $S$ is a subtype of type $T$. Any term of
type $S$ can then be regarded via the subsumption rule (\textsc{sub})
as a term of type $T$.

As usual, subtyping is reflexive (\textsc{refl}) and transitive
(\textsc{trans}).  The other rules in Figure~\ref{dot-sub} determine
the subtyping relations for the different forms of types. 

To prove that a type $S$ is a subtype of a refinement type $T \refine
z {\seq D}$, it must hold that $S$ is a subtype of $T$ and that $S$
expands to declarations that subsume the declarations $\seq D$
(\textsc{$\sub$-refine}). The refinement type itself is a subtype of its parent type $T$
(\textsc{refine-$\sub$})

A type selection $p.L$ is a subtype of the upper bound $U$ of
$L$ in $p$ (\textsc{tsel-$\sub$}) and it is a supertype of its lower
bound $S$ (\textsc{$\sub$-tsel}).  Function types are subject to the
standard co-/contravariant subtyping rule (\textsc{$\sub$-$\tfun$}).
A singleton type $p\sing$ is a subtype of any underlying type of path
$p$ (\textsc{single-$\sub$}). The final six rules in
Figure~\ref{dot-sub} turn the subtyping relation into a lattice with 
meets $\tand$, joins $\tor$, bottom element $\Bot$ and top element $\Top$.

\begin{figure}
  \figurebox{

    \begin{multicols}{2}[\judgement{Well-formed types}{$\Gamma \ts T \wf$}]

      \infrule[\textsc{refine-wf}]
      {\Gamma \ts T \wf \\ 
       \Gamma \envplus {z: T \refine z {\seq D}} \ts \seq {D \wf}}
      {\Gamma \ts T \refine z {\seq D} \wf}\smallskip

      \infrule[\textsc{$\tand$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tand T' \wf}

      \infax[\textsc{$\Bot$-wf}]
      {\Gamma \ts \Bot \wf}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{tsel-wf}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \wf}
      {\Gamma \ts p.L \wf}

      \infrule[\textsc{$\tfun$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tfun T' \wf}

      \infrule[\textsc{$\tor$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tor T' \wf}

      \infax[\textsc{$\Top$-wf}]
      {\Gamma \ts \Top \wf}
      
    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed declarations}{$\Gamma \ts D \wf$}]
      \infrule[\textsc{tdecl-wf}]
      {\Gamma \ts S \wf \spcomma U \wf}
      {\Gamma \ts \Ldecl L S U \wf}

      \infrule[\textsc{vdecl-wf}]
      {\Gamma \ts T \wf}
      {\Gamma \ts \ldecl l T \wf}

    \end{multicols}
      
  }

\caption{The DOT Calculus : Well-Formedness}\label{dot-wf}
\end{figure}


\subsection*{Declaration Subsumption}

The declaration subsumption judgement $\Gamma \ts D \sub D'$ in Figure~\ref{dot-sub}
states that in environment $\Gamma$
the declaration $D$ subsumes the declaration $D'$. There are two
rules, one for type declarations and one for value declarations. 
Rule (\textsc{tdecl-$\sub$})
states that a type declaration $\Ldecl L S U$ subsumes another type declaration $\Ldecl L {S'} {U'}$
if $S'$ is a subtype of $S$ and $U$ is a subtype of $U'$. In other words, the set of types
between $S$ and $U$ is contained in the set of types between $S'$ and $U'$.
Rule (\textsc{vdecl-$\sub$})
states that a value declaration $\ldecl l T$ subsumes another value declaration $\ldecl l T'$
if $T$ is a subtype of $T'$.

Declaration subsumption is extended a binary relation between sequences of
declarations as follows: $\seq{D} <: \seq{D'}$ iff $\forall D'_i \exists D_j. D_j \sub D'_i$.

\subsection*{Well-formedness}

The well-formedness judgement $\Gamma \ts T \wf$ in Figure~\ref{dot-wf}
states that in environment $\Gamma$ the type $T$ is well-formed.

A singleton type $p \sing$ is well-formed if the path $p$ is
well-typed (\textsc{single-wf}).  A type selection $p.L$ is
well-formed if the type $T$ is well-formed, $L$ is a member of $T$, and the lower bound of $L$
in $T$ is also well-formed (\textsc{tsel-wf}). The latter condition
has the effect that the lower bound of a type $p.L$ may not
refer directly or indirectly to a type containing $p.L$ itself
--- if it would, the well-formedness judgement of $p.L$ would
not have a finite proof. No such restriction exists for the upper
bound of $L$. The upper bound may in fact refer back to the
type. Hence, recursive class types and F-bounded abstract types are
both expressible. A refinement type $T \refine z {\seq D}$ is
well-formed if the parent type $T$ is well-formed and every
declaration in $\seq D$ is well-formed in an environment augmented by
the binding of the self-reference $z$ to the refinement type itself
(\textsc{refine-wf}). The other forms of types in DOT are all
well-formed if their constituent types are well-formed.

Well-formedness extends straightforwardly to
declarations with the judgement $\Gamma \ts D \wf$. All declarations are well-formed if their constituent types
are well-formed.

\section{Program Examples}

\begin{figure}
 \figurebox{\renewcommand{\baselinestretch}{0.6}
@@
val root = new Any { rootThis =>
  trait Unit extends Any {}
  val unit: Any => rootThis.Unit
  trait Boolean extends Any {
    val ifNat: (rootThis.Unit => rootThis.Nat) => (rootThis.Unit => rootThis.Nat) => rootThis.Nat
  }
  val false: rootThis.Unit => rootThis.Boolean
  val true: rootThis.Unit => rootThis.Boolean
  trait Nat extends Any {
    val isZero: rootThis.Unit => rootThis.Boolean
    val pred: rootThis.Unit => rootThis.Nat
    val succ: rootThis.Unit => rootThis.Nat
    val add: rootThis.Nat => rootThis.Nat
  }  
  val zero: rootThis.Unit => rootThis.Nat
  val successor: rootThis.Nat => rootThis.Nat
  val add2: rootThis.Nat => rootThis.Nat => rootThis.Nat
  val error: rootThis.Unit => Bot
} {
  val unit = (x: Any) => val u = new root.Unit; u
  val false = (u: root.Unit) => {
    val ff = new root.Boolean {
      val ifNat = (t: root.Unit => root.Nat) => (e: root.Unit => root.Nat) => e(root.unit)
    }
    ff
  }
  val true = (u: root.Unit) => {
    val tt = new root.Boolean {
      val ifNat = (t: root.Unit => root.Nat) => (e: root.Unit => root.Nat) => t(root.unit)
    }
    tt
  }
  val zero = (u: root.Unit) => {
    val zz = new root.Nat { 
      val isZero = (u: root.Unit) => root.false(root.unit)
      val succ = (u: root.Unit) => root.successor(zz)
      val pred = (u: root.Unit) => error(root.unit)
      val add = (other: root.Nat) => add2(other, zz)
    }
    zz
  }
  val successor = (n: root.Nat) => {
    val ss = new root.Nat {
      val isZero = (u: root.Unit) => root.true(root.unit)
      val succ = (u: root.Unit) => root.successor(ss)
      val pred = (u: root.Unit) => n
      val add = (other: root.Nat) => add2(other, ss)
    }
    ss
  }
  val add2 = (n1: root.Nat) => (n2: root.Nat) =>
    n1.isZero(root.unit).ifNat
     ((u: root.Unit) => n2)
     ((u: root.Unit) => root.add2(n1.pred(root.unit))(n2.succ(root.unit)))
  val error = (u: root.Unit) => error(x)
}
@@
}
\caption{Some root classes}\label{code:root}
\end{figure}


\begin{figure}
 \figurebox{
@@
val genLists = new Any {  
  trait ListPackage extends Any { thisListPackage =>
    type Elem
    type ListOfElem = List { type Elem = thisList.Elem }
    trait List extends Any {
      val isEmpty: root.Unit => root.Boolean
      val head: root.Unit => root.Boolean
      val tail: root.Unit => thisListPackage.ListOfElem
      val prepend: Elem => ListOfElem
    }
    val nil: root.Unit => ListOfElem
    val cons: Elem => ListOfElem => ListOfElem
  }
}
val natLists = new ListPackage { 
  type Elem = Nat
} {
  val nil = (u: root.Unit) => {
    val nn = new natLists.List {
      val isEmpty = (u: root.Unit) => root.true(root.unit)
      val head = (u: root.Unit) => root.error(root.unit)
      val tail = (u: root.Unit) => root.error(root.unit)
      val prepend = (x: root.Nat) => natLists.cons(x, nn)
    }
    nn
  }
  val cons = (x: natLists.Elem) => (xs: natLists.ListOfElem) => {
    val cc = new natLists.List {
      val isEmpty = (u: root.Unit) => root.false(root.unit)
      val head = (u: root.Unit) => x
      val tail = (u: root.Unit) => xs
      val prepend = (x: root.Nat) => natLists.cons(x, cc)
    }
    cc
  }
}
@@
}
\caption{List classes}\label{code:more}
\end{figure}

\end{document}
