\documentclass{article}
\usepackage{url}

\begin{document}
\bibliographystyle{plain}
\title{Package Universes Architecture}
\author{Alexander Spoon}
\date{$LastChangedDate$}
\maketitle

\section{Preamble}
This is a living document describing the package universes
architecture.  It is not formally peer reviewed.  It is updated over
time in response to comments.

The canonical web location for this document is currently:
\begin{quote}
  \url{http://scala.epfl.ch/~spoon/sbaz}
\end{quote}
Feedback should be directed either to the author or to the Scala
mailing list.


\section{Introduction}
Many long-term collaborations can be described in terms of developing
a shared library of content that is stored in discrete packages.  
%XXX find collaboration theory here!
Examples include systems like the Debian's Advanced Package Tool and
Squeak's SqueakMap for managing software packages, SuperSwikis for
managing Etoys content \cite{steinmetz02:learning}, and Wikis for
managing written articles \cite{ward01:wikiway}.  Frequently the
individual packages evolve over time: software gains new
features and bug fixes, media content is updated, and articles are
edited.  Additionally, this content frequently includes dependencies.
A software package for email reading might depend on having an HTML
formatter, and an active essay in an Etoys-like media system might
require that particular widget classes be loaded before the essay is
viewable.  Finally, while many such collaborations require few firm
rules, it is common for wide-open freedom in the collaboration space
to be limited to some form of membership in an existing external
community such as a single software-development team or a single
classroom.  While such restrictions tend to be simple, the precise
policies vary widely among different collaboration communities.


This paper describes \emph{package universes}, an architecture for
supporting these kinds of collaborations.  The architecture is unusual
for focussing on communal sets of packages instead of on individual
packages.  Users are assumed to operate within one package universe at
a time.  The user's package universe provides a limited view of the
available packages.  The limitation simplifies many technical issues
of package distribution, while still allowing simple configurations
that support a variety of useful human organizations and
software-engineering processes.


\section{Why package universes exist}


Why focus on package universes as the core of the architecture?
Packages are only \emph{convenient} when they have been
\emph{configured} consistently with other packages a user wants to
use.  Individual packages are only \emph{reliable}, in practice, when
they are \emph{tested} with respect to other packages the user is
interested in.  Therefore, package in general cannot be convenient and
cannot be reliable except in relation to a set of other packages.
As a result, the set of all possible packages naturally divides itself into
smaller sets of mutually compatible packages.

Besides being part of the fundamental nature of packages, however,
these sets of mutually compatible packages provide useful leverage.
Sets of packages provide a useful place to insert policy, they
simplify dependency management, and they allow for relatively short
names of packages.

These sets are called \emph{package universes} in this system because
they constitute the entire set of packages visible from an individual
user workspace.  Intuitively, it is as if each user operates within a
bubble universe, unable to see anything except what has been placed in
that universe.  Such universes can be quite large, easily including
tens of thousands of packages, but each one is always limited to
packages that have been explicitly added and thus which fit each
universe's policy for inclusion.



\section{Explicit management of package universes}
    they are there anyway

    it makes it easy to manage

    it does mean that packages get released potentially multiple times.
    this is normal, however: packages need slight reconfigurations depending
    on which universe they participate in.  This is no different from
    having a separate package of gcc for every linux distro.

properties:
  can be composed to form new ones

  dependency management is simplified due to limited set of packages

  practical, as exemplified by experience with Debian and by
  the presently described implementation

  policy neutral.  each universe can have its own policies for
  what goes in, what changes are allowed, etc.

  no central control; universe-based collaboration groups
  can be built bottom-up.  especially important for allowing
  private use, e.g. for commercial activity.  further, individual
  universes with different policies may be combined, e.g. if a
  commercial work group wants to have local packages plus use
  publically available packages.
   

Package names are considered unique within a particular universe.
Thus, if two packages have the same name but a different version
number, they are considered as holding different revisions of the same
content.

Globally unique names are not necessary for the functioning of package
universes.  Instead, names can be short and easily manageable by
humans.  Debian shows that short human-readable names, names that do
not, for example, include embedded DNS hostnames, are practical for
libraries at least as large as 10,000 packages.

The single universe-wide scope is intended designed to support a
person's workspace. It is not a suggestion or endorsement that the
packages themselves should refer to each other via the universe-wide
names.  Instead, it is intended to allow a human user a terse name for
each package in their local library, thereby supporting creative
development.


Packages can depend on each other.  The dependencies of a package are
listed by name, for example, ``Celeste 1.4 depends on HTML-Parser,''
with no version specified for the depended-on package.  A more refined
dependency system is described below, but this approach appears
sufficient for practical usage.  The sufficiency of such a simple
dependency system follows from the fundamental design decision that
each universe includes a limited set of carefully chosen packages.
Because of this design, software can simply select the newest version
of any needed package without needing to select among a large number
of versions.

This simple versioning approach does not encompass version changes
that break intentionally compatibility.  Instead, the package names
must be made different, so that the universes software can distinguish
the mutually incompatible package versions.  For example, if ``libc
version 5.100'' and ``libc version 6.101'' break compatibility, then
they could be considered separate packages by naming them ``libc5
version 100'' and ``libc6 version 101.''


Version numbers must be totally ordered.  Simple integers suffice as
version numbers, as do hierarchical version numbers such as
``2.3.54c.''  The software support has a strong bias towards
downloading and installing the most recent available versions of
requested packages.  Thus, the version numbers must be totally ordered
so that the software can always decide which versions of a set of
versions is the most preferable.



\section{Definition of package universes}

The overall architecture is that a package universe implements a
\emph{shared library} of \emph{packages} on the network, while
individual users have a \emph{workspace} that includes a \emph{local
library}.  The local library consists of packages selectively
downloaded from the shared library.

A package is the unit of interchange of content.  It might contain any
form of content---software, media components, written essays, etc.  A
package can be loaded and unloaded from the user's local library.
Each package has a name, used to refer to the package from the
workspace and (possibly) from the content of other packages, and it
has a version number, used to distinguish different revisions of the same
content.

The shared library is implemented by a package universe.  A package
universe is defined as an evolving set of packages.  Users can
retrieve the current list of packages, add packages to the set, and
remove packages from the set.

\emph{Primitive} package universes are directly implemented of a list
of packages on a server.  \emph{Compound} package universes can be
formed from underlying universes using the following operators:
\begin{itemize}
\item Union.  Any two universes may be combined to form a larger
      universe.  The ordering of the union is specified, thus allowing
      the contents of one universe to override another.  The effect
      is the same as (multiple) inheritance in an object-oriented language.

\item Positive filtering.  It is possible to make a universe that
      includes just those packages from another universe whose
      name is included in some list of package names.

\item Negative filtering.  Likewise, it is possible to make a universe
      that \emph{excludes} packages whose name is on some list.

\item Name-based union.  A useful combination of these filters, named
      separately due to its frequent utility, is to take the union of
      two universes but filter out all packages from one universe
      which have any same-named package in the other universe.  This
      approach provides inheritance where overrides are based on names
      of packages instead of name-version tuples.
\end{itemize}


It seems likely that the compound universe used by a particular
community might be a complicated application of several of the above
operators.  Additionally, it seems likely that communities will
refine the definition of its package universe(s) over time.  For both
reasons, it seems helpful to store the definition of the universe on
the network and have the client reference the definition via a URL.
The community can then modify the definition of the universe in a
single central location.  Each individual user's software can
periodically and automatically download a fresh copy of the universe
definition.

This form of automatic updating leads to the intriguing possibility of
storing the universe definition itself in some universe.  For example,
there might be meta-universes that hold only universe descriptions.
More practically, the universe description might be stored inside
itself, leading to meta-circularity between a universe and its
description.


\section{Package dependencies (not yet implemented)}

XXX

provides, alternative dependencies, suggests


\section{Access control}

Security policies are supported by providing an interface to
primitive universes based on \emph{capabilities} \cite{miller00:caps}.
Universe servers on the network only allow operations when the
requestor presents a sufficient capability to use that request.  The
servers themselves do not use usernames and passwords nor any other
from of access-control lists.

Capabilities can be implemented as unguessably large random numbers.
Holding a capability is then equivalent to knowing the large number
associated with the capability.  A capability can be transmitted to a
user (or to a software object) by sending him or her the number.  If a
capability is revoked on a server, then all holders of that capability
lose the authority associated with that capability.


Primitive universe servers respond to capabilities designating the
following operations:
\begin{enumerate}
\item Download the list of package descriptions.
\item Upload a new package description.
\item Remove an existing package description.
\item Create a new capability of the first three kinds.
\item Revoke a capability of the first three kinds.
\end{enumerate}
The second and third capabilities could be subdivided in a mature
implementation to allow access to packages only of a specific name,
but in the relatively congenial communities envisioned, such
fine-grained control may be more of a burden than a help.


The final two capabilities are useful for implementing security
policies.  Different users can be given different capabilities for the
same operations.  Fine-grained security policies can then be implemented by
selectively creating and revoking individual capabilities.  Revoking
the capability held by one user, for example, does not affect other
capabilities held by other users.
Capabilities-based authorization provide sufficient control to
implement useful policies, several of which are described in the next
section.


Specific software support for individual policies is not required.
Whoever holds the capability-creation and capability-revocation
capabilities can create and remove capabilities at will.  Capabilities
can be transferred to users via simple email.  Thus, the capabilities
approach allows ad hoc policies to be defined without needing to write
any code.

On the other hand, it is also possible to write additional code to use
an existing user database and permissions system.  A program can
authenticate users and check whether they have permission to access
the package universe.  If that program is given the
capability-creation and -revocation capabilities for a particular
universe, then it can give out temporary capabilities to users in the
existing user database.


\section{Sample configurations}
The package universes architecture allows convenient implementation of
a variety of community organizations and software-engineering
processes.
\begin{itemize}
\item No restrictions.  Wikis have proven that effective and useful
      communities can be built even with no security restrictions at
      all.  This policy can be implemented by posting all of the
      universe's capabilities on a public web page.

\item Full access, but only to community members.  Many open-source
      projects have an organization of this form, including Debian's
      ``Debian Developers'' and FreeBSD's ``committers.''  This policy
      can be implemented by giving the capability-creation and
      -revocation capabilities to the membership gatekeepers.
      The last step of admitting a new member to the community is to
      give them their own capabilities to manipulate the community
      universes.

\item Single provider, multiple users.  An individual developer wants
      to provide a suite of packages to be used by a larger
      community---possibly the world, or possibly a limited base of
      subscribers.  To implement this policy, the developer can keep a
      universe's package-adding capabilities for personal use but
      publish the universe-retrieval capability to the desired
      user base.

\item Moderation queues.  Sometimes it is desirable to have a large
      community contribute suggested packages, but a smaller group to
      decide on what is actually included.  A moderation queue can be
      implemented as a separate universe where the package-addition
      capability is made available to whichever community is allowed
      to contribute suggestions (perhaps the entire world).
      Moderators would have both a reading capability for the
      moderation queue and a package-adding capability for the main
      universe, and could copy packages from the queue to the main
      universe whenever they are deemed appropriate.


\item Private local development.  Individual groups can form their own
      universe for private development without needing to coordinate
      with any central organization.  They simply create the universe
      and share keys with members of the group according to their
      own local security policy.

\item Public libraries plus local development.  The above organization
      can be refined by allowing developers to use publicly
      available packages even as they develop packages for private
      use.  This policy can be implemented by taking the union of the
      local universe with one ore more public universes.


\item Localized versions of packages.  Local groups may want to use
      something similar to a widely-scoped universe, but override
      specific packages with localized versions.  A particular example
      is language-specific versions of packages.  Users want to use
      the localized version of a package whenever one is available,
      but the global version otherwise.  This policy is implemented by
      creating a universe holding the localized packages, and then
      having users operate in the name-based union of this universe
      with the public one.

\item Stable versus unstable streams.  Projects frequently distinguish
      between stable and unstable streams of development.  The stable
      streams include packages that are heavily tested and deemed to
      be reliable, while the unstable streams include packages that
      are more current and featureful but are not as reliable.  A
      project can implement this policy by having separate universes
      for each development stream.  

\item Freezing new stable distributions.  A common process for
      generating stable distributions of code is to take an unstable
      stream, start testing it, and disallow any patches except for
      bug fixes.
%CITE can i find anything on this?
      After some
      point, the distribution is \emph{frozen} and considered a stable
      release.  Such processes can be implemented by manipulating the
      outstanding capabilities as time passes.  The testing phase can
      be implemented by revoking all outstanding add-package
      capabilities and switching over to a moderation queue process.  The
      actual freeze can be implemented by destroying the moderation
      queue and revoking the remaining add-package capabilities.  The
      frozen universe can then be duplicated, with one fork hosting
      a new development stream while the other becomes is designated
      a stable release.
\end{itemize}



\section{Related work}
There has been much work on packages and package distribution.  This
section is currently overly brief.  Feedback is welcome, so that the
section can be enriched to give the author's comparison to different
systems of interest.


\subsection{Packages themselves}

XXX

this is about distro, not packaging.  by focussing on package universes,
instead of individual packages, pressure is releaved from the package
format itself.

examples of bullet-proof, universe-independent package approaches are
osgi and michel's thing.


\subsection{Package distribution}

Debian and its Advanced Package Tool (APT)
%CITE
are the primary inspiration behind the package universes architecture.
Package universes develop the design further in a few ways:
\begin{itemize}
\item Package universes supports different ways to combine universes.
      APT only supports simple unions.  Particularly interesting are
      name-based union and the name-based filtering, which support
      similar functionality to APT's \emph{pinning} mechanism.

\item Package universes supports uploading packages and package
      descriptions in the core architecture, while APT leaves
      uploading for separate tools.

\item In support of uploading, package universes has a refined,
      policy-neutral approach to access control.
\end{itemize}

The Yellowdog Update Manager (yum) is also inspired by APT, and deserves
some mention.
%XXX so mention
%CITE 


Conary is an ambitious system that aims to provide full version
control across distributed ad-hoc repositories.  
%CITE
It shares with
package universes the design goal of allowing new repositories to be
formed from existing ones without needing any kind of permission from
the original ones.
%XXX check on that

It is an open design question whether a package distribution system
should include version control.  Conary explores the design path of
including version control, thus achieving a more featureful system.
Package universes, on the other hand, intentionally reject
sophisticated versioning, under the conjecture that most users are
content to upgrade their machines regularly.  Instead of branching
within a repository, the approach in the package universes
architecture is to fork a universe into two separate universe.
Instead of having users remain at earlier revisions within a
repository, the package universes approach is to fork the universe
into a fast-moving universe and a slow-moving one.

The cost in complexity is large.  Package universes contain packages
which contain files.  To contrast, Conary has four ways to group
files: groups, packages, components, and filesets.  The Conary
documentation gives considerable attention to the specific case of a
local administrator having a ``local shadow'', which is accomplished
in package universes by the generic mechanism of name-based union.
Package universes, in general, rely on copying instead of
in-repository branching; the difference is analagous to subversion's
branching and tagging approach
%CITE
versus CVS's.
%CITE


Due to Conary's complexity, package universes provides, at the very
least, a simple conceptual core.  It may be, however, that the extra
complexity is so high as to negate the extra functionality.  Time and
experience will hopefully shed light on this open question.



\bibliography{architecture.bib}

\end{document}



