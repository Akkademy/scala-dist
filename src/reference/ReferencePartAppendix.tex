\appendix
\chapter{Scala Syntax Summary}
\todo{introduce SeqPattern syntax}

(this needs to be updated)

The lexical syntax of Scala is given by the following grammar in EBNF
form.

\begin{lstlisting}
  upper          ::=  `A' | $\ldots$ | `Z' | `$\Dollar$' | `_' $\mbox{\rm\em and Unicode Lu}$
  lower          ::=  `a' | $\ldots$ | `z' $\mbox{\rm\em and Unicode Ll}$
  letter         ::=  upper | lower $\mbox{\rm\em and Unicode categories Lo, Lt, Nl}$
  digit          ::=  `0' | $\ldots$ | `9'
  opchar         ::=  $\mbox{\rm\em ``all other characters in
  \U{0020-007F} and Unicode categories}$
                      $\mbox{\rm\em  Sm, So except parentheses ([{}]) and periods''}$

  op             ::=  opchar {opchar} 
  varid          ::=  lower idrest
  plainid        ::=  upper idrest
                   |  varid
                   |  op
  id             ::=  plainid
                   |  `\`' stringLit `\`'
  idrest         ::=  {letter | digit} [`_' op]

  integerLiteral ::=  (decimalNumeral | hexNumeral | octalNumeral) ['L' | 'l']
  decimalNumeral ::=  `0' | nonZeroDigit {digit}
  hexNumeral     ::=  `0' `x' hexDigit {hexDigit}
  octalNumeral   ::=  `0' octalDigit {octalDigit}
  digit          ::=  `0' | nonZeroDigit
  nonZeroDigit   ::=  `1' | $\ldots$ | `9'
  octalDigit     ::=  `0' | $\ldots$ | `7'

  floatingPointLiteral 
                 ::=  digit {digit} `.' {digit} [exponentPart] [floatType]
                   |  `.' digit {digit} [exponentPart] [floatType]
                   |  digit {digit} exponentPart [floatType]
                   |  digit {digit} [exponentPart] floatType
  exponentPart   ::=  ('E' | 'e') ['+' | '-'] digit {digit}
  floatType      ::=  'F' | 'f' | 'D' | 'd'

  booleanLiteral ::=  true | false

  characterLiteral::= `\'' printableChar `\''
                   |  `\'' charEscapeSeq `\''

  stringLiteral  ::=  `"' {stringElement} `"'
                   |  `"""' multiLineChars `"""'
  stringElement  ::=  printableCharNoDoubleQuote 
                   |  charEscapeSeq
  multiLineChars ::=  {['"' ['"']] charNoDoubleQuote}

  symbolLiteral  ::=  `'' plainid

  comment        ::=  `/*' ``any sequence of characters'' `*/'
                   |  `//' ``any sequence of characters up to end of line''
\end{lstlisting}

The context-free syntax of Scala is given by the following EBNF
grammar.

\begin{lstlisting}
  Literal        ::=  integerLiteral
                   |  floatingPointLiteral
                   |  booleanLiteral
                   |  characterLiteral
                   |  stringLiteral
                   |  symbolLiteral
                   |  null

  StableId       ::=  id
                   |  Path `.' id
  Path           ::=  StableId
                   |  [id `.'] this
                   |  [id '.'] super [`[' id `]']`.' id

  Type           ::=  InfixType `=>' Type
                   |  `(' [Types | `=>' Type] `)' `=>' Type
                   |  InfixType
  InfixType      ::=  CompoundType {id [NewLine] CompoundType}
  CompoundType   ::=  SimpleType {with SimpleType} [Refinement]
  SimpleType     ::=  {Annotation} SimpleType1
  SimpleType1    ::=  SimpleType1 TypeArgs
                   |  SimpleType1 `#' id
                   |  StableId
                   |  Path `.' type
                   |  `(' Type ')'
                   |  `{' [Type `,' [Types [`,']]] '}'
  TypeArgs        ::=  `[' Types `]'
  Types           ::=  Type {`,' Type}
  Refinement      ::=  `{' [RefineStat {StatementSeparator RefineStat}] `}'
  RefineStat      ::=  Dcl
                    |  type TypeDef
                    |
  Ascription      ::=  `:' Annotation {Annotation} 
                    |  `:' CompoundType

  Exprs           ::=  Expr {`,' Expr} [`:' `_' `*']
  Expr            ::=  (Bindings | Id) `=>' Expr
                    |  Expr1
  Expr1           ::=  if `(' Expr1 `)' {NewLine} Expr [[`;'] else Expr]
                    |  try `{' Block `}' [catch  `{' CaseClauses `}'] 
                       [finally Expr]
                    |  while `(' Expr `)' {NewLine} Expr
                    |  do Expr [StatementSeparator] while `(' Expr ')'
                    |  for (`(' Enumerators `)' | `{' Enumerators `}') 
                       {NewLine} [yield] Expr
                    |  for (`(' InitCondStep `)' | `{' InitCondStep `}') Expr
                    |  throw Expr
                    |  return [Expr]
                    |  [SimpleExpr `.'] id `=' Expr
                    |  SimpleExpr ArgumentExprs `=' Expr
                    |  PostfixExpr Ascription
                    |  PostfixExpr match `{' CaseClauses `}'
                    |  MethodClosure
  PostfixExpr     ::=  InfixExpr [id [NewLine]]
  InfixExpr       ::=  PrefixExpr
                    |  InfixExpr id [NewLine] (InfixExpr | ArgumentExprs)
  PrefixExpr      ::=  [`-' | `+' | `~' | `!' | `&'] SimpleExpr 
  SimpleExpr      ::=  Literal
                    |  Path
                    |  `(' [Expr] `)'
                    |  BlockExpr
                    |  new Template 
                    |  SimpleExpr `.' id 
                    |  SimpleExpr TypeArgs
                    |  SimpleExpr ArgumentExprs
                    |  XmlExpr
  ArgumentExprs   ::=  `(' [Exprs] ')'
                    |  BlockExpr
  MethodClosure   ::=  `.' Id {`.' Id | TypeArgs | ArgumentExprs}
  BlockExpr       ::=  `{' CaseClauses `}'
                    |  `{' Block `}'
                    |  `{' [Expr1 `,' {Expr1 `,'} [Expr1]] '}'
  Block           ::=  {BlockStat StatementSeparator} [ResultExpr]
  BlockStat       ::=  Import
                    |  [implicit] Def
                    |  {LocalModifier} TmplDef
                    |  Expr1
                    |
  ResultExpr      ::=  Expr1
                    |  (Bindings | Id `:' CompoundType) `=>' Block

  Enumerators     ::=  Generator {StatementSeparator Enumerator}
  Enumerator      ::=  Generator
                    |  val Pattern1 `=' Expr
                    |  Expr
  Generator       ::=  val Pattern1 `<-' Expr
  InitCondStep    ::=  [Expr | VarDef] StatementSeparator 
                       [Expr] StatementSeparator [Expr]

  CaseClauses     ::=  CaseClause { CaseClause }
  CaseClause      ::=  case Pattern [`if' PostfixExpr] `=>' Block 

  Constr          ::=  StableId [TypeArgs] {`(' [Exprs] `)'}

  Pattern         ::=  Pattern1 { `|' Pattern1 }
  Pattern1        ::=  varid `:' TypePattern
                    |  `_' `:' TypePattern
                    |  Pattern2
  Pattern2        ::=  varid [`@' Pattern3]
                    |  Pattern3
  Pattern3        ::=  SimplePattern [ '*' | '?' | '+' ]
                    |  SimplePattern { id [NewLine] SimplePattern }
  SimplePattern   ::=  `_'
                    |  varid
                    |  Literal
                    |  StableId [ `(' [Patterns] `)' | `{' [Patterns] `}' ]
                    |  `(' [Patterns] `)'
                    |  `{' [Pattern `,' [Patterns [`,']]] `}'
                    |  XmlPattern
  Patterns        ::=  Pattern {`,' Pattern}

  TypePattern     ::=  SimpleTypePattern {with SimpleTypePattern}
  SimpleTypePattern ::= SimpleTypePattern1 [ TypePatternArgs ]
                    | `{' [ArgTypePattern `,' [ArgTypePatterns [`,']]] '}'
  SimpleTypePattern1 ::= SimpleTypePattern1 "#" Id
                    |  StableId 
                    |  Path `.' type 
  TypePatternArgs ::=  `[' ArgTypePatterns ']'
  ArgTypePatterns ::=  ArgTypePattern {`,' ArgTypePattern}
  ArgTypePattern  ::=  varid 
                    |  `_' 
                    |  Type

  TypeParamClause ::=  [NewLine] `[' VariantTypeParam {`,' VariantTypeParam} `]'
  FunTypeParamClause ::= [NewLine] `[' TypeParam {`,' TypeParam} `]'
  VariantTypeParam::=  [`+' | `-'] TypeParam
  TypeParam       ::=  id [>: Type] [<: Type] [<% Type]
  ParamClauses    ::=  {ParamClause} [[NewLine] `(' implicit Params `)']
  ParamClause     ::=  [NewLine] `(' [Params] ')'} 
  Params          ::=  Param {`,' Param}
  Param           ::=  {Annotation} id [`:' ParamType]
  ParamType       ::=  [`=>'] Type [`*']
  ClassParamClauses::= {ClassParamClause} 
                       [[NewLine] `(' implicit ClassParams `)']
  ClassParamClause::=  [NewLine] `(' [ClassParams ')'
  ClassParams     ::=  ClassParam {`' ClassParam}
  ClassParam      ::=  {Annotation} [{Modifier} (`val' | `var')] Param
  Bindings        ::=  `(' Binding {`,' Binding `)'
  Binding         ::=  id [`:' Type]

  Modifier        ::=  LocalModifier 
                    |  AcessModifier
                    |  override
  LocalModifier   ::=  abstract
                    |  final
                    |  sealed
                    |  implicit
  AccessModifier  ::=  (private | protected) ["[" AccessQualifier "]"]
  AccessQualifier ::=  id | this

  Annotation       ::= `[' AnnotationExpr {`,' AnnotationExpr} `]' [NewLine]
                    |  `@' AnnotationExpr [NewLine]
  AnnotationExpr   ::=  Constr [`{' {NameValuePair} `}']
  NameValuePair   ::=  id `=' PrefixExpr

  Template        ::=  TemplateParents [TemplateBody]
  TemplateParents ::=  Constr {with SimpleType}
  TemplateBody    ::=  `{' [TemplateStat {StatementSeparator TemplateStat}] `}'
  TemplateStat    ::=   Import
                    |  {Annotation} {Modifier} Def
                    |  {Annotation} {Modifier} Dcl
                    |  Expr
                    |

  Import          ::=  import ImportExpr {`,' ImportExpr}
  ImportExpr      ::=  StableId `.' (id | `_' | ImportSelectors)
  ImportSelectors ::=  `{' {ImportSelector `,'} 
                       (ImportSelector | `_') `}'
  ImportSelector  ::=  id [`=>' id | `=>' `_']

  Dcl             ::=  val ValDcl
                    |  var VarDcl
                    |  def FunDcl
                    |  type TypeDcl

  ValDcl          ::=  ids `:' Type
  VarDcl          ::=  ids `:' Type
  FunDcl          ::=  FunSig [`:' Type]
  FunSig          ::=  id [FunTypeParamClause] {ParamClause}
  TypeDcl         ::=  id [>: Type] [<: Type]

  Def             ::=  val PatDef
                    |  var VarDef
                    |  def FunDef
                    |  type {NewLine} TypeDef
                    |  TmplDef
  PatDef          ::=  Pattern2 {`,' Pattern2} [`:' Type] `=' Expr
  VarDef          ::=  ids [`:' Type] `=' Expr
                    |  ids `:' Type `=' `_'
  FunDef          ::=  FunSig `:' Type `=' Expr
                    |  FunSig `{' Block `}'
                    |  this ParamClause ParamClauses (`=' ConstrExpr | ConstrBlock)
  TypeDef         ::=  id [TypeParamClause] `=' Type

  TmplDef         ::=  ([case] class ClassDef
                    |  [case] object ObjectDef
                    |  trait TraitDef
  ClassDef        ::=  id [TypeParamClause] {Annotation} [AccessModifier] ClassParamClauses
                       [`requires' SimpleType] ClassTemplate 
  ClassTemplate   ::=  [extends TemplateParents] [[NewLine] TemplateBody]
  TraitDef        ::=  id [TypeParamClause]
                       [`requires' SimpleType] TraitTemplate
  TraitTemplate   ::=  [extends MixinParents] [[NewLine] TemplateBody]
  MixinParents    ::=  SimpleType {`with' SimpleType}
  
  ObjectDef       ::=  id ClassTemplate

  ConstrExpr      ::=  SelfInvocation | ConstrBlock
  ConstrBlock     ::=  `{' SelfInvocation {StatementSeparator BlockStat} `}'
  SelfInvocation  ::=  this ArgumentExprs {ArgumentExprs}

  CompilationUnit ::=  [package QualId StatementSeparator] TopStatSeq
  TopStatSeq      ::=  TopStat {StatementSeparator TopStat}
  TopStat         ::=  {Annotation} {Modifier} TmplDef
                    |  Import
                    |  Packaging
                    |
  Packaging       ::=  package QualId `{' TopStatSeq `}'

  QualId          ::=  id {`.' id}
  ids             ::=  id {`,' id}
\end{lstlisting}

\chapter{Change Log}

\section{Changes in Version 2.0}

Scala in its second version is different in some details from the
first version of the language. There have been several additions and
some old idioms are no longer supported. This appendix summarizes
the main changes.

\subsection*{New Keywords}

The following three words are now reserved; they cannot be used as
identifiers (\sref{sec:idents})
\begin{lstlisting}
implicit    match     requires
\end{lstlisting}

\subsection*{Newlines as Statement Separators}

Newlines can now be used as statement separators in place of
semicolons (\sref{sec:newlines})

\subsection*{Syntax Restrictions}

There are some other situations where old constructs no longer work:

\paragraph{\em Pattern matching expressions} The \lstinline@match@
keyword now appears only as infix operator between a selector
expression and a number of cases, as in:
\begin{lstlisting}
  expr match {
    case Some(x) => ...
    case None => ...
  }
\end{lstlisting}
Variants such as \lstinline@ expr.match {...} @ 
or just
\lstinline@ match {...} @
are no longer supported.

\paragraph{\em ``With'' in extends clauses}. The idiom
\begin{lstlisting}
class C with M { ... }
\end{lstlisting}
is no longer supported. A \lstinline@with@ connective is only allowed
following an \lstinline@extends@ clause. For instance, the line
above would have to be written
\begin{lstlisting}
class C extends AnyRef with M { ... } .
\end{lstlisting}
However, assuming \lstinline@M@ is a trait (see
\ref{sec:traits}), it is also legal to write
\begin{lstlisting}
class C extends M { ... }
\end{lstlisting}
The latter expression is treated as equivalent to
\begin{lstlisting}
class C extends S with M { ... }
\end{lstlisting}
where \lstinline@S@ is the superclass of \lstinline@M@.

\paragraph{\em Regular Expression Patterns} The only form of regular
expression pattern that is currently supported is a sequence pattern,
which might end in a sequence wildcard \code{_*}. Example:
\begin{lstlisting}
case List(1, 2, _*) => ... // will match all lists starting with \code{1,2}.
\end{lstlisting}
It is at current not clear whether this is a permanent restriction. We
are evaluating the possibility of re-introducing full regular
expression patterns in Scala.

\subsection*{Selftype Annotations}

The recommended syntax of selftype annotations has changed. 
\begin{lstlisting}
class C: T extends B { ... }
\end{lstlisting}
becomes
\begin{lstlisting}
class C requires T extends B { ... }
\end{lstlisting}
That is, selftypes are now indicated by the new \lstinline@requires@
keyword. The old syntax is still available but is considered deprecated. 
Conversions}

\subsection*{For-comprehensions}

For-comprehensions (\sref{sec:for-comprehensions}) now admit value and
pattern definitions. Example:
\begin{lstlisting}
for {
  val x <- List.range(1, 100)
  val y <- List.range(1, x)
  val z = x + y
  isPrime(z)
} yield Pair(x, y)
\end{lstlisting}
Note the definition ~\lstinline@val z = x + y@ as the third item in
the for-comprehension. 

\subsection*{Conversions}

The rules for implicit conversions of methods to functions
(\sref{sec:impl-conv}) have been tightened. Previously, a
parameterized method used as a value was always implicitly converted
to a function. This could lead to unexpected results when method
arguments where forgotten. Consider for instance the statement below:
\begin{lstlisting}
show(x.toString)
\end{lstlisting}
where \lstinline@show@ is defined as follows:
\begin{lstlisting}
def show(x: String) = Console.println(x) .
\end{lstlisting}
Most likely, the programmer forgot to supply an empty argument list
\lstinline@()@ to \lstinline@toString@. The previous Scala version would
treat this code as a partially applied method, and expand it to:
\begin{lstlisting}
show(() => x.toString())
\end{lstlisting}
As a result, the address of a closure would be printed instead of the
value of \lstinline@s@.

Scala version 2.0 will apply a conversion from partially applied
method to function value only if the expected type of the expression
is indeed a function type. For instance, the conversion would not be
applied in the code above because the expected type of
\lstinline@show@'s parameter is \lstinline@String@, not a function
type. 

The new convention disallows some previously legal code. Example:
\begin{lstlisting}
def sum(f: int => double)(a: int, b: int): double =
  if (a > b) 0 else f(a) + sum(f)(a + 1, b)

val sumInts  =  sum(x => x)  // error: missing arguments
\end{lstlisting}
The partial application of \lstinline@sum@ in the last line of
the code above will not be converted to a function type. Instead, the
compiler will produce an error message which states that arguments for method
\lstinline@sum@ are missing. The problem can be fixed by providing an
expected type for the partial application, for instance by annotating
the definition of \lstinline@sumInts@ with its type:
\begin{lstlisting}
val sumInts: (int, int) => double  =  sum(x => x)  // OK
\end{lstlisting}

On the other hand, Scala version 2.0 now automatically applies methods
with empty parameter lists to \lstinline@()@ argument lists when
necessary. For instance, the \lstinline@show@ expression above will
now be expanded to
\begin{lstlisting}
show(x.toString()) .
\end{lstlisting}

Scala version 2.0 also relaxes the rules of overriding with respect to
empty parameter lists. The revised definition of {\em matching
members} (\sref{sec:members}) makes it now possible to override a
method with an explicit, but empty parameter list \lstinline@()@ with
a parameterless method, and {\em vice versa}. For instance, 
the following class definition is now legal:
\begin{lstlisting}
class C {
  override def toString: String = ...
}
\end{lstlisting}
Previously this definition would have been rejected, because the
\lstinline@toString@ method as inherited from
\lstinline@java.lang.Object@ takes an empty parameter list.  

\subsection*{Class Parameters}

A class parameter may now be prefixed by \lstinline@val@ or
\lstinline@var@ (\sref{sec:class-defs}). 

\subsection*{Private Qualifiers}

Previously, Scala had three levels of visibility: {\em private},
{\em protected} and {\em public}. There was no way to
restrict accesses to members of the current package, as in Java. Scala
2 now defines access qualifiers that let one express this level of
visibility, among others. In the definition
\begin{lstlisting}
private[C] def f(...)
\end{lstlisting}
access to \lstinline@f@ is restricted to all code within the class or
package \lstinline@C@ (which must contain the definition of
\lstinline@f@) (\sref{sec:modifiers})

\subsection*{Changes in the Mixin Model}\label{sec:mixin-classes}

The model which details mixin composition of classes has changed
significantly. The main differences are:
\begin{enumerate}
\item
We now distinguish between {\em traits} that are used as mixin classes
and normal classes. The syntax of traits has been generalized from
version 1.0, in that traits are now allowed to have mutable
fields. However, as in version 1.0, traits may still do not have
constructor parameters.
\item
Member resolution and super accesses are now both defined in terms of
a {\em class linearization}. 
\item
Scala's notion of method overloading has been generalized; in
 particular, it is now possible to have overloaded variants of the
 same method in a subclass and in a superclass, or in several different
 mixins. This makes method overloading in Scala conceptually the
 same as in Java.
\end{enumerate}
The new mixin model is explained in more detail in
\sref{sec:globaldefs}.

\subsection*{Implicit Parameters}

Views in Scala 1.0 have been replaced by the more general concept of
implicit parameters (\sref{sec:implicits})

\subsection*{Flexible Typing of Pattern Matching}

The new version of Scala implements more flexible typing rules when it
comes to pattern matching over heterogeneous class hierarchies
(\sref{sec:pattern-match}). A {\em heterogeneous class hierarchy} is
one where subclasses inherit a common superclass with different
parameter types.  With the new rules in Scala version 2.0 one can
perform pattern matches over such hierarchies with more precise
typings that keep track of the information gained by comparing the
types of a selector and a matching pattern (\sref{ex:eval}).
This gives Scala capabilities analogous to guarded algebraic data types.

\section{Changes in Version 2.3.0}

\subsection*{Procedures} A simplified syntax for functions returning
\lstinline@unit@ has been introduced (\sref{sec:procedures}). 
Scala now allows the following shorthands:

\begin{tabbing}
\lstinline@def f(params)@     \tab\tab\tab \=$\mbox{for}$  \tab
\lstinline@def f(params): unit@ \\
\lstinline@def f(params) { ... }@  \>$\mbox{for}$    \tab
\lstinline@def f(params): unit = { ... }@
\end{tabbing}

\subsection*{Type Patterns} The syntax of types in patterns has been 
refined (\sref{sec:type-patterns}). Scala now distinguishes between
type variables (starting with a lower case letter) and types as type
arguments in patterns.  Type variables are bound in the pattern. Other
type arguments are, as in previous versions, erased. The Scala
compiler will now issue an ``unchecked'' warning at places where type
erasure might compromise type-safety.

\subsection*{Standard Types} 

The recommended names for the two bottom classes in Scala's type
hierarchy have changed as follows:
\begin{lstlisting}
All      ==>     Nothing
AllRef   ==>     Null
\end{lstlisting}
The old names are still available as type aliases.

\section{Changes in Version 2.3.2}

\subsection*{Extractors}

It is now possible to define patterns independently of case classes,
using \code{unapply} methods in extractor objects
(\sref{sec:extractor-patterns}). 
Here is an example:
\begin{lstlisting}
object Twice {                              
  def apply(x:Int): int = x*2
  def unapply(z:Int): Option[int] = if(z%2==0) Some(z/2) else None
}
val x = Twice(21) 
x match { case Twice(n) => Console.println(n) } // prints 21
\end{lstlisting}
In the example, \lstinline@Twice@ is an extractor object with two methods:
\begin{itemize}
\item
The \code{apply} method is used to build even numbers.
\item
The \code{unapply} method is used to decompose an even number; it is
in a sense the reverse of \code{apply}. \lstinline@unapply@ methods return option types: 
\code{Some(...)} for a match that suceeds, \code{None} for a match that fails.
Pattern variables are returned as the elements of \code{Some}. If there are several
variables, they are grouped in a tuple.
\end{itemize}
In the second-to-last line, \code{Twice}'s \code{apply} method is used
to construct a number \code{x}. In the last line, \code{x} is tested
against the pattern
\code{Twice(n)}. This pattern succeeds for even numbers and assigns to the variable
\code{n} one half of the number that was tested. The pattern match makes use of
the \code{unapply} method of object \code{Twice}. More details on extractors can be found
in the paper ``Matching Objects with Patterns'' by Emir, Odersky and Williams.
 
\subsection*{Tuples}

A new lightweight syntax for tuples has been introduced
(\sref{sec:tuples}). For any sequence of types $T_1 \commadots T_n$,

\begin{tabular}{lll}
$\{T_1 \commadots T_n \}$ &is a shorthand for&
\lstinline@Tuple$n$[$T_1 \commadots T_n$]@.  
\end{tabular}

Analogously, for any sequence of expressions or patterns $x_1
\commadots x_n$,

\begin{tabular}{lll}
$\{x_1 \commadots x_n \}$ &is a shorthand for&
\lstinline@Tuple$n$($x_1 \commadots x_n$)@.
\end{tabular}

\subsection*{Infix operators of greater arities}

It is now possible to use methods which have more than one parameter
as infix operators (\sref{sec:infix-operations}). In this case, all
method arguments are written as a normal parameter list in parentheses. Example:
\begin{lstlisting}
class C {
  def +(x: int, y: String) = ...
}
val c = new C
c + (1, "abc")
\end{lstlisting}

\subsection*{Deprecated attribute}

A new standard attribute \lstinline@deprecated@ is available (\sref{sec:attributes}). If a
member definition is marked with this attribute, any reference to the
member will cause a ``deprecated'' warning message to be emitted.

\section{Changes in Version 2.3.4}

\subsection*{Object-local private and protected}

The \lstinline@private@ and \lstinline@protected@ modifiers now accept
a \lstinline@[this]@ qualifier (\sref{sec:modifiers}). A definition $M$ which is labelled
\lstinline@private[this]@ is private, and in addition can be accessed
only from within the current object. That is, the only legal prefixes
for $M$ are \lstinline@this@ or \lstinline@$C$.this@.  Analogously, A
definition $M$ which is labelled \lstinline@protected[this]@ is
protected, and in addition can be accessed only from within the
current object.

\subsection*{Access modifiers for primary constructors}

The primary constructor of a class can now be marked \code{private} or
\code{protected} (\sref{sec:class-defs}). If such an access modifier is given, it comes
between the name of the class and its value parameters. Example:
\begin{lstlisting}
class C[T] private (x: T) { ... }
\end{lstlisting}

\subsection*{Attributes are serialized}

Attributes are now serialized so that they can be read by
compile-time or run-time tools (\sref{sec:attributes}). Class \code{scala.Attribute} has two
sub-traits which are used to indicate how attributes are
retained. Instances of an attribute class inheriting from trait
\code{scala.ClassfileAttribute} will be stored in the generated class
files. Instances of an attribute class inheriting from trait
\code{scala.StaticAttribute} will be visible to the Scala type-checker
in every compilation unit where the attributed symbol is accessed. 






\end{document}

